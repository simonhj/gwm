#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-3-Clause

if [ -z "${BASH_VERSION:-}" ]; then
  echo "gwm: this tool requires bash" >&2
  exit 2
fi

set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  gwm new <branch>
  gwm shell <branch> [command]
  gwm path <branch>
  gwm repo
  gwm remove [--force] <branch>
  gwm list
  gwm clean
  gwm rebase_all [<branch>]

Commands:
  new <branch>     Create a git worktree for the branch and print its path.
  shell <branch> [command]
                    Start a login shell inside the worktree directory. If [command] is provided, execute it in that shell.
  path <branch>    Print the worktree directory path for the branch.
  repo             Print the main repository root path.
  remove [--force] <branch>
                   Remove the worktree directory for the branch. With --force, remove even if it has local changes.
  list             List gwm-managed worktree directories.
  clean            Remove clean worktree directories (no unstaged or uncommitted changes).
  rebase_all [<branch>]
                    Rebase all worktrees onto <branch>. If <branch> is not provided,
                    defaults to main or master depending on what the repo uses.

Environment:
  GWM_WORKTREE_LOCATION  Base directory for worktrees (default: ~/worktrees).
EOF
}

die() {
  echo "gwm: $*" >&2
  exit 1
}

require_git_repo() {
  if ! repo_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "not a git repository"
  fi
  printf '%s' "$repo_root"
}

main_repo_root() {
  local repo_root key value

  repo_root=$(require_git_repo)

  if git worktree list --porcelain >/dev/null 2>&1; then
    while read -r key value; do
      if [ "$key" = "worktree" ] && [ -d "$value/.git" ]; then
        printf '%s' "$value"
        return 0
      fi
    done < <(git worktree list --porcelain 2>/dev/null)
  fi

  printf '%s' "$repo_root"
}

repo_name() {
  local repo_root

  repo_root=$(require_git_repo)
  repo_root=${repo_root%/}
  printf '%s' "${repo_root##*/}"
}

expand_base_dir() {
  local base_dir
  base_dir="${GWM_WORKTREE_LOCATION:-$HOME/worktrees}"

  case "$base_dir" in
    ~|~/*)
      base_dir="${base_dir/#~/$HOME}"
      ;;
  esac

  printf '%s' "$base_dir"
}

select_shell() {
  local candidate

  candidate="${SHELL:-}"
  if [ -n "$candidate" ] && [ -x "$candidate" ]; then
    printf '%s' "$candidate"
    return 0
  fi

  if command -v getent >/dev/null 2>&1; then
    candidate=$(getent passwd "$USER" | cut -d: -f7)
    if [ -n "$candidate" ] && [ -x "$candidate" ]; then
      printf '%s' "$candidate"
      return 0
    fi
  fi

  printf '%s' "/bin/bash"
}

detect_base_ref() {
  if git show-ref --verify --quiet "refs/heads/main"; then
    printf '%s' "main"
  else
    printf '%s' "master"
  fi
}

command_new() {
  local branch repo_root repo_name base_dir worktree_path

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  mkdir -p "$base_dir/$repo_name"

  if [ -e "$worktree_path" ]; then
    die "worktree path already exists: $worktree_path"
  fi

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$worktree_path" "$branch"
  else
    git worktree add -b "$branch" "$worktree_path"
  fi

  printf '%s\n' "$worktree_path"
}

command_shell() {
  local branch repo_name base_dir worktree_path shell command

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  if [ ! -d "$worktree_path" ]; then
    die "worktree path not found: $worktree_path"
  fi

  shell=$(select_shell)

  cd "$worktree_path"

  if [ "$#" -gt 1 ]; then
    shift
    command="$*"
    exec "$shell" -l -c "$command"
  fi

  exec "$shell" -l
}

command_path() {
  local branch repo_name base_dir worktree_path

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  printf '%s\n' "$worktree_path"
}

command_repo() {
  local repo_root

  repo_root=$(main_repo_root)
  printf '%s\n' "$repo_root"
}

command_remove() {
  local force branch repo_name base_dir worktree_path

  force=0

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --force|-f)
        force=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "unknown option for remove: $1"
        ;;
      *)
        break
        ;;
    esac
  done

  if [ "$#" -ne 1 ]; then
    usage >&2
    exit 1
  fi

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  if [ ! -d "$worktree_path" ]; then
    die "worktree path not found: $worktree_path"
  fi

  if [ "$force" -eq 1 ]; then
    git worktree remove --force "$worktree_path"
  else
    git worktree remove "$worktree_path"
  fi
}

command_list() {
  local repo_name base_dir root entry branch status_count status_label
  local base_ref counts ahead behind

  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  root="$base_dir/$repo_name"
  base_ref=$(detect_base_ref)

  if [ ! -d "$root" ]; then
    return 0
  fi

  printf '%-20s %-12s %-13s %s\n' "Branch" "Changes" "Ahead/Behind" "Path"

  shopt -s nullglob
  for entry in "$root"/*; do
    if [ ! -d "$entry" ]; then
      continue
    fi

    branch=${entry##*/}
    status_count=$(git -C "$entry" status --porcelain 2>/dev/null | wc -l)
    if [ "$status_count" -eq 0 ]; then
      status_label="clean"
    else
      status_label="$status_count changes"
    fi

    if git -C "$entry" rev-parse --verify --quiet "$base_ref" >/dev/null; then
      counts=$(git -C "$entry" rev-list --left-right --count "$base_ref...HEAD" 2>/dev/null || true)
      if [ -n "$counts" ]; then
        read -r behind ahead <<<"$counts"
        counts="$ahead/$behind"
      else
        counts="-"
      fi
    else
      counts="-"
    fi

    printf '%-20s %-12s %-13s %s\n' "$branch" "$status_label" "$counts" "$entry"
  done
  shopt -u nullglob
}

command_clean() {
  local repo_name base_dir root entry

  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  root="$base_dir/$repo_name"

  if [ ! -d "$root" ]; then
    return 0
  fi

  shopt -s nullglob
  for entry in "$root"/*; do
    if [ ! -d "$entry" ]; then
      continue
    fi

    if [ "$(git -C "$entry" status --porcelain 2>/dev/null | wc -l)" -eq 0 ]; then
      printf '%s\n' "Removing clean worktree: $entry"
      git worktree remove "$entry"
    fi
  done
  shopt -u nullglob
}

command_rebase_all() {
  local repo_name base_dir root entry branch base_ref
  local -A results

  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  root="$base_dir/$repo_name"

  # Determine the base branch
  if [ "$#" -eq 1 ] && [ -n "$1" ]; then
    base_ref="$1"
  else
    base_ref=$(detect_base_ref)
  fi

  if [ ! -d "$root" ]; then
    die "no worktrees found"
  fi

  printf '%s\n' "Rebasing all worktrees onto $base_ref"

  shopt -s nullglob
  for entry in "$root"/*; do
    if [ ! -d "$entry" ]; then
      continue
    fi

    branch=${entry##*/}
    
    # Skip the base branch itself
    if [ "$branch" = "$base_ref" ]; then
      results["$branch"]="SKIPPED (base branch)"
      continue
    fi

    printf '%s\n' "Rebasing $branch..."

    # Attempt to rebase
    if git -C "$entry" rebase "$base_ref" >/dev/null 2>&1; then
      results["$branch"]="SUCCESS"
    else
      # Rebase failed, leave worktree in rebase state
      results["$branch"]="FAILED (in rebase)"
    fi
  done
  shopt -u nullglob

  # Print summary
  printf '\n%s\n' "Rebase Summary:"
  printf '%s\n' "==============="
  for branch in "${!results[@]}"; do
    printf '%-20s %s\n' "$branch:" "${results[$branch]}"
  done
}

if [ "$#" -lt 1 ]; then
  usage >&2
  exit 1
fi

case "$1" in
  new)
    if [ "$#" -ne 2 ]; then
      usage >&2
      exit 1
    fi
    command_new "$2"
    ;;
  shell)
    if [ "$#" -lt 2 ]; then
      usage >&2
      exit 1
    fi
    shift
    command_shell "$@"
    ;;
  path)
    if [ "$#" -ne 2 ]; then
      usage >&2
      exit 1
    fi
    command_path "$2"
    ;;
  repo)
    if [ "$#" -ne 1 ]; then
      usage >&2
      exit 1
    fi
    command_repo
    ;;
  remove)
    shift
    command_remove "$@"
    ;;
  list)
    if [ "$#" -ne 1 ]; then
      usage >&2
      exit 1
    fi
    command_list
    ;;
  clean)
    if [ "$#" -ne 1 ]; then
      usage >&2
      exit 1
    fi
    command_clean
    ;;
  rebase_all)
    if [ "$#" -gt 2 ]; then
      usage >&2
      exit 1
    fi
    shift
    command_rebase_all "$@"
    ;;
  -h|--help|help)
    usage
    ;;
  *)
    usage >&2
    exit 1
    ;;
esac
