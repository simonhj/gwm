#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-3-Clause

if [ -z "${BASH_VERSION:-}" ]; then
  echo "gwm: this tool requires bash" >&2
  exit 2
fi

set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  gwm new <branch>
  gwm shell <branch> [command]
  gwm path <branch>
  gwm remove <branch>
  gwm list
  gwm clean

Commands:
  new <branch>    Create a git worktree for the branch and print its path.
  shell <branch> [command]  Start a login shell inside the worktree directory. If [command] is provided, execute it in that shell.
   path <branch>   Print the worktree directory path for the branch.
   remove <branch> Remove the worktree directory for the branch.
   list            List gwm-managed worktree directories.
   clean           Remove clean worktree directories (no unstaged or uncommitted changes).

Environment:
  GWM_WORKTREE_LOCATION  Base directory for worktrees (default: ~/worktrees).
EOF
}

die() {
  echo "gwm: $*" >&2
  exit 1
}

require_git_repo() {
  if ! repo_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "not a git repository"
  fi
  printf '%s' "$repo_root"
}

repo_name() {
  local repo_root

  repo_root=$(require_git_repo)
  repo_root=${repo_root%/}
  printf '%s' "${repo_root##*/}"
}

expand_base_dir() {
  local base_dir
  base_dir="${GWM_WORKTREE_LOCATION:-$HOME/worktrees}"

  case "$base_dir" in
    ~|~/*)
      base_dir="${base_dir/#~/$HOME}"
      ;;
  esac

  printf '%s' "$base_dir"
}

select_shell() {
  local candidate

  candidate="${SHELL:-}"
  if [ -n "$candidate" ] && [ -x "$candidate" ]; then
    printf '%s' "$candidate"
    return 0
  fi

  if command -v getent >/dev/null 2>&1; then
    candidate=$(getent passwd "$USER" | cut -d: -f7)
    if [ -n "$candidate" ] && [ -x "$candidate" ]; then
      printf '%s' "$candidate"
      return 0
    fi
  fi

  printf '%s' "/bin/bash"
}

detect_base_ref() {
  if git show-ref --verify --quiet "refs/heads/main"; then
    printf '%s' "main"
  else
    printf '%s' "master"
  fi
}

command_new() {
  local branch repo_root repo_name base_dir worktree_path

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  mkdir -p "$base_dir/$repo_name"

  if [ -e "$worktree_path" ]; then
    die "worktree path already exists: $worktree_path"
  fi

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$worktree_path" "$branch"
  else
    git worktree add -b "$branch" "$worktree_path"
  fi

  printf '%s\n' "$worktree_path"
}

command_shell() {
  local branch repo_name base_dir worktree_path shell command

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  if [ ! -d "$worktree_path" ]; then
    die "worktree path not found: $worktree_path"
  fi

  shell=$(select_shell)

  cd "$worktree_path"

  if [ "$#" -gt 1 ]; then
    shift
    command="$*"
    exec "$shell" -l -c "$command"
  fi

  exec "$shell" -l
}

command_path() {
  local branch repo_name base_dir worktree_path

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  printf '%s\n' "$worktree_path"
}

command_remove() {
  local branch repo_name base_dir worktree_path

  branch="$1"
  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  worktree_path="$base_dir/$repo_name/$branch"

  if [ ! -d "$worktree_path" ]; then
    die "worktree path not found: $worktree_path"
  fi

  git worktree remove "$worktree_path"
}

command_list() {
  local repo_name base_dir root entry branch status_count status_label
  local base_ref counts ahead behind

  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  root="$base_dir/$repo_name"
  base_ref=$(detect_base_ref)

  if [ ! -d "$root" ]; then
    return 0
  fi

  printf '%-20s %-12s %-13s %s\n' "Branch" "Changes" "Ahead/Behind" "Path"

  shopt -s nullglob
  for entry in "$root"/*; do
    if [ ! -d "$entry" ]; then
      continue
    fi

    branch=${entry##*/}
    status_count=$(git -C "$entry" status --porcelain 2>/dev/null | wc -l)
    if [ "$status_count" -eq 0 ]; then
      status_label="clean"
    else
      status_label="$status_count changes"
    fi

    if git -C "$entry" rev-parse --verify --quiet "$base_ref" >/dev/null; then
      counts=$(git -C "$entry" rev-list --left-right --count "$base_ref...HEAD" 2>/dev/null || true)
      if [ -n "$counts" ]; then
        read -r behind ahead <<<"$counts"
        counts="$ahead/$behind"
      else
        counts="-"
      fi
    else
      counts="-"
    fi

    printf '%-20s %-12s %-13s %s\n' "$branch" "$status_label" "$counts" "$entry"
  done
  shopt -u nullglob
}

command_clean() {
  local repo_name base_dir root entry

  repo_name=$(repo_name)
  base_dir=$(expand_base_dir)
  root="$base_dir/$repo_name"

  if [ ! -d "$root" ]; then
    return 0
  fi

  shopt -s nullglob
  for entry in "$root"/*; do
    if [ ! -d "$entry" ]; then
      continue
    fi

    if [ "$(git -C "$entry" status --porcelain 2>/dev/null | wc -l)" -eq 0 ]; then
      printf '%s\n' "Removing clean worktree: $entry"
      git worktree remove "$entry"
    fi
  done
  shopt -u nullglob
}

if [ "$#" -lt 1 ]; then
  usage >&2
  exit 1
fi

case "$1" in
  new)
    if [ "$#" -ne 2 ]; then
      usage >&2
      exit 1
    fi
    command_new "$2"
    ;;
  shell)
    if [ "$#" -lt 2 ]; then
      usage >&2
      exit 1
    fi
    shift
    command_shell "$@"
    ;;
  path)
    if [ "$#" -ne 2 ]; then
      usage >&2
      exit 1
    fi
    command_path "$2"
    ;;
  remove)
    if [ "$#" -ne 2 ]; then
      usage >&2
      exit 1
    fi
    command_remove "$2"
    ;;
  list)
    if [ "$#" -ne 1 ]; then
      usage >&2
      exit 1
    fi
    command_list
    ;;
  clean)
    if [ "$#" -ne 1 ]; then
      usage >&2
      exit 1
    fi
    command_clean
    ;;
  -h|--help|help)
    usage
    ;;
  *)
    usage >&2
    exit 1
    ;;
esac
